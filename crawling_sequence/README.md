// 기존 계획서
목표: 네트워크상에 공개된 사진들을 안전하게 확인하고 저장하는 것.

조건: 
프리라이센스 사진이 업로드되어있는 접근가능한 주소 https://~~~/~~~/1.webp 부터 https://~~~/~~~/1000.webp까지 제공됨

구상한 작동방식:
1. 목표 주소에 접근하기 전, 주소 형식이 잘못되었는지 혹은 주소가 신뢰할 수 있는 주소인지 확인한다.
2. 해당 주소에 접근했을 때 악성 코드가 삽입될 가능성을 감지한다.
3. 안전이 확보된 뒤에 해당 주소에서 얻은 사진을 개인pc에 저장한다.
4. 일련의 과정을 자동화하기.

필요 지식: webp의 작동방식, 주소를 접근했을 때 악성코드가 심어져있을지 확인할 보안 지식

구현에 사용할 언어: C++

// 법적 문제를 확인한 결과, 실제 외부 서버를 대상으로 크롤링을 실시할 경우 scraping에 해당할 수 있음.
// 사설 서버를 생성하는 것도 비용이 들고, 무엇보다 서버를 만드는 건 대여의 개념이기에 여전히 법적 문제를 피하기 어려움.
// 따라서 외부 서버의 주소가 아닌 컴퓨터 내부에 로컬 파일 구조를 만들어 접근하는 것으로 변경함.
// 이에 따라 https 프로토콜이나 SSL, TLS 인증 및 보안에 대한 실습은 불가능해짐.
// 다만 로컬 디스크의 데이터를 읽는 것으로 바뀌었기에 파일 시스템 I/O 최적화 실습은 가능해짐.

// 현재 계획서
목표: 내 컴퓨터 안에 있는 대량의 Webp 파일들을 대상으로 바이너리 구조를 분석하여 파일의 무결성을 검증하고, 조작되거나
악성 코드가 삽입된 파일들을 사전에 탐지하는 스캐너 구현.

조건:
WebP형식의 파일들이 특정 directory 내부에 1000개 존재한다. 이 중 일부는 데이터가 깨져있고, 일부는 조작된 데이터가 삽입되어있다.

구상한 작동방식:
1. WebP 파일들이 있는 directory를 입력받고, 해당 directory의 위치를 확인한다.
// Directory에 있는 파일들을 검증하기 시작함.
2. 파일 확장자가 아닌 바이너리 헤더를 직접 파싱함으로써 해당 파일이 실제 WebP 형식인지 확인한다. //File Integrity Check
3. WebP 컨테이너 내부의 청크를 탐색해 비정상적인 크기나 알 수 없는 메타데이터가 삽입되었는지 여부를 감지한다. // Structural Analysis
4. 데이터 내부에 암호화된 악성 코드가 숨겨져 있는지 확인하기 위해 픽셀 데이터 영역의 엔트로피 계산 //Entropy Analysis
5. 이 때, 분류 속도의 향상을 위해 파일 분석을 병렬 처리한다. //Multi-threaded Scanning
6. 검증이 끝난 파일들을 안전, 경고, 위험군으로 분류하고 분석 리포트를 생성한다. //Logging and Reporting

필요 지식: 파일 시스템 I/O 최적화, 정적 바이너리 분석, 운영체제 파일 처리 API, 메모리 오버플로우 방어, thread 구현 및 C++에 대한 기본적인 지식

구현에 사용할 언어: C++
